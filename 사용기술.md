## 소개

어떠한 기술을 사용했는지, 왜 사용했는지, 해당 기술에 대한 제 생각은 어떠한지를 말씀드리겠습니다.

## TypeScript

많은 기업들이 TypeScript를 요구하고, 제 개인적으로 컴파일 단계에서 오류를 잡을 수 있다는 점에 대해서 만족하기 때문에 이를 썼습니다.

## React

다른 프레임워크를 배우지 못한 상황이기도 하고, Next.js도 사용하기 위해서 사용했습니다.

## Next.js

서버 사이드 렌더링(SSR)을 구현하기 위해 사용했습니다. article 페이지와 category 페이지에 적용했습니다. 서버 사이드 렌더링을 하는 이유는 검색 엔진 최적화 (SEO) 때문이었습니다. 아무래도 블로그 플랫폼이다 보니 검색에 잡히는 것이 중요하다고 생각했습니다.

## Firebase

가장 유명해서 사용했습니다.

Firebase에서 제공하는 데이터베이스 중 하나인 Firestore를 사용했는데요. 저는 불만족스러웠습니다. 이유는 다음과 같습니다.

- SQL은 컬럼명을 변경할 수 있지만 Firestore는 MongoDB와 유사한 형식이기 때문에 불가능합니다.

- 페이지네이션을 하기 위해서는 기존의 자료들을 다 가져와야 합니다.

- 댓글이나 글에서 작성자의 이름이나 사진을 가지고 오려면 프론트 측에서 또 Firestore에 요청을 해야 했습니다. 만약 SQL이면 join을 하면 되기 때문에 한 번만 요청할 수 있습니다.

## SCSS로 CSS 모듈

처음에는 styled-components를 사용했습니다. 그런데 다음과 같은 에러가 계속 일어났습니다.

```
Warning: Prop `className` did not match. Server: "sc-bqWxrE dFiDCh" Client: "sc-gswNZR jTOsfL"
```

그래서 SCSS로 CSS 모듈을 사용했습니다.

## Redux

인증 정보를 전역 상태로 관리하기 위해 사용했습니다.

Firebase의 currentUser로 사용하면 정보를 가져오는데 시간이 걸리기 때문에 이를 사용했습니다.

Context API를 사용하면 다음과 같은 문제가 생기기 때문에 이를 사용했습니다.

- 다른 reducer(또는 context)가 들어오면 태그 네스팅이 일어납니다.

- 해당 setState나 dispatch(useReducer를 사용한 경우)가 있는 컴포넌트부터 전체가 다 렌더링이 됩니다. 해당 앱의 경우 \_app에서 이를 사용할 것인데, header만 다시 렌더링이 되면 되는데 본문이나 footer도 다시 렌더링이 되면 비효율적입니다.

## Cypress

테스팅으로는 Cypress를 사용했습니다.

Vitest나 Jest와 같은 unit 테스팅 툴은 제가 원하는 테스팅을 하기에는 기능이 부족하다고 생각했습니다.

React Testing Library도 배워 보았지만 복잡하기도 했고, 여전히 화면을 보지 않고 한다는 측면이 답답했습니다.

하지만 Cypress가 만족스럽기만 하지는 않았습니다.

- 브라우저를 실제 돌리다보니 속도가 느렸습니다.

- 같은 코드라고 하더라도 될 때가 있고 안 될 때가 있었습니다. 오류가 났을 때, spec별로 테스트를 할 때는 해당 spec만 다시 돌리면 되기 때문에 시간이 오래 걸리지 않았지만 모든 spec을 한 번에 검사할 때는 시간이 오래 걸렸습니다.

## Mochawesome

Mochawesome을 통해 테스팅 리포트를 작성하였습니다. [(링크)](https://bada3670.github.io/ShareGround/mochawesome/report.html)

## Next.js의 API Route 및 Mock Service Worker (MSW)

원래는 API Route를 사용하지 않고 Firebase의 getDoc 등을 컴포넌트에서 직접 사용했습니다.

그러다가 보안을 이유로 사용하려고 했습니다. Firebase URL이 브라우저 뜨지 않게 하기 위해서였습니다. 하지만 Firebase 측이 이런 것을 당연히 고려했을 것이라는 생각도 들었고, 해당 URL에 접속하면 아무것도 없어서 괜찮다고 생각했습니다. 또한 서버 사이드 렌더링 (SSR)에서는 URL이 absolute URL이어야 했습니다. 하지만 당시에는 이 사실을 몰랐습니다. 그래서 포기했습니다.

그러다가 absolute URL이 무엇인지 알게 되었고, DB를 건드리지 않고 테스팅을 하고 싶었어서 API Route를 사용하였습니다. 예를 들어 Firebase의 getDoc을 /api/articles에 GET 요청을 보내는 것으로 바꾸었습니다. Cypress 상으로 URL을 mocking하는 것을 알았지만 getDoc 등의 메서드를 mocking하는 것은 몰랐기 때문입니다. (아마 없는 것 같습니다.)

쓰다 보니 다른 장점이 있었는데 그것은 컴포넌트 쪽의 코드가 단순해졌다는 것이었습니다. 예를 들어 글을 삭제할 때 파일이 있다면 이도 삭제해야 하는데, 이 경우 원래는 컴포넌트에서 파일을 삭제하는 코드와 글을 삭제하는 코드를 둘 다 작성해야 했습니다. 하지만 API Route를 쓰면 해당 정보만 보내면 그 처리는 API Route에서 합니다. 처음부터 저렇게 코드를 작성한 것은 아니었습니다. 처음에는 Firebase의 메서드에 따라 작성했습니다. 그런데 하다 보니 저렇게 하는 것이 나아 보여서 저렇게 했습니다.

그러다가 '꼭 DB를 건드리지 않고 테스팅을 해야 하나?'라는 생각이 들었습니다. 이러한 생각을 하다 보니 프론트엔드와 백엔드가 동시에 개발하는 경우를 생각하게 되었습니다. 그래서 mock 서버의 필요성을 느꼈습니다. 그래서 이를 만들려고 했습니다.

처음에는 MSW만 생각을 했습니다. 그러다가 갑자기 API Route로도 mock 서버를 만들 수 있다는 생각이 떠올랐습니다. 브랜치만 다르게 하면 되니까요. 그래서 두 방법을 다 썼습니다. 각각의 코드는 m-apiroute 브랜치와 m-msw 브랜치에서 확인하실 수 있습니다. 안타깝게도 서버 사이드 렌더링 (SSR)에서 클라이언트 사이드가 서버 사이드에 영향을 줄 수 없으므로 전부를 구현하지는 못하고 데이터를 읽는 것을 중심으로 구현을 했습니다.

## husky

CI(Continuous Integration)을 하기 위해 사용했습니다.

dev 브랜치에서 husky를 통해 git commit을 하기 전에 다음의 일들이 일어나도록 했습니다.

- Cypress 테스팅

- Mochawesome 실행

- 폴더 및 파일 정리

이를 통과하면 dev 브랜치에서 main 브랜치로 pull request를 보내는 방식으로 했습니다.
