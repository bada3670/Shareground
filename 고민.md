## 맨 위로 가기 버튼에 debouncing을 적용하지 않은 이유

코드가 복잡해집니다.

처리를 하는 과정에서 자원이 많이 사용되는 것 같지 않아 보였습니다.

## 로그인/회원가입을 할 때 submit이 아닌 click으로 한 이유

동일한 input 이메일과 input 비밀번호로 로그인과 회원가입을 동시에 처리하고 싶었습니다.

그런데 submit으로는 로그인을 눌렀는지 회원가입을 눌렀는지 판단할 수가 없었습니다.

## 댓글을 Realtime에서 Firestore로 바꾼 이유

댓글 삭제 버튼을 누르는데 갑자기 Realtime이 반영이 되어서 잘못 누르게 될 수 있습니다.

Realtime에서 새로 고침을 하지 않으면 작성자가 다른 사람이 되는 현상이 발생했습니다.

## header의 category 및 auth의 웹 접근성

처음에는 그냥 hover만 하면 밑에 목록이 열리도록 하였습니다.

근데 그렇게 하려니 tab으로 해당 항목들이 열리지 않았습니다.

그래서 고민을 하던 중 CSS hover를 쓰면 안 되고 mouseenter와 mouseleave를 써야 함을 알았습니다.

그리고 그 과정에서 mouseover, mouseout와 mouseenter, mouseleave의 차이점을 알게 되었습니다.

## article을 수정하거나 삭제할 때 searchList를 변경하지 않는 이유

시간이 오래 걸립니다. 과정을 보면 다음과 같습니다. getDoc을 통해 배열을 가져와서 일일이 해당 아이디와 맞는지를 체크한 후 updateDoc을 해야 합니다. updateDoc은 await을 할 필요가 없습니다. 하지만 getDoc과 배열에서 체크하는 것은 반드시 그 자리에서 해야 합니다.

getDoc을 안 하고 Redux에서 가져오면 문제가 발생합니다. 왜냐하면 그동안 다른 유저가 글을 올렸을 수 있기 때문입니다. 다른 유저가 글을 올린 상태에서 해당 유저가 Redux에서 가져온 것을 반영해서 올리면 다른 유저가 올린 글이 삭제됩니다.

onSnapshot을 쓸 수도 있겠지만 그렇게 되면 부담이 커집니다.

배열이 아니라 key value로 하면 순환할 필요가 없지 않냐고 물으실 수 있습니다. 하지만 개수가 많아서 옛날 것을 삭제하려고 할 때 문제가 생깁니다. 왜냐하면 자료들 사이에 순서가 없기 때문입니다.

이미 오래된 글이어서 search에 없을 수 있습니다. 이러면 헛수고가 됩니다.

새로운 글들이 올라오면 자연스럽게 삭제됩니다.

## Card 컴포넌트에 작성자를 적지 않은 이유

이미 로딩이 SSR로 인해 체감상 많이 느린 상황(로딩 표시를 할 수 없으므로)에서 더 느려질 수 있습니다.

페이지네이션의 경우 바로 파이어베이스 측에서 하는 것이 아니라 기존의 것을 다 가져온 후 또 불러야 하는 상황입니다. 즉, 지금도 많이 느리다는 것입니다.

## 작성 목록과 관심 목록을 users collection이 아닌 articles collection에 저장한 이유

예를 들어 작성 목록을 생각하면 다음과 같습니다.

만약 users에 각 articleid를 넣는다면 articleid 하나 읽고, 글 가져오고, articleid 하나 읽고, 또 글 가져오는 번거로운 과정이 펼쳐집니다.

하지만 articles에 userid를 넣는다면 쿼리를 통해 금방 가져올 수 있습니다.

## Auth 컴포넌트, Search 컴포넌트

해당 컴포넌트들의 경우 빈 엘리먼트(&lt;&gt;&lt;/&gt;)를 반환합니다.

이를 만든 이유는 다음과 같습니다. React-Redux에서는 dispatch를 하려면 Provider 컴포넌트 안에 있어야 하고, 해당 컴포넌트들의 기능상 모든 페이지에 적용되어야 합니다. Create React App이나 Vite의 경우 감싸는 Provider와 다른 컴포넌트들 사이에 중간 컴포넌트를 만들면 되지만 Next.js로는 불가능합니다. React-Redux를 쓰지 않을까도 생각해 보았지만 이 방법이 떠올라서 사용하였습니다.
