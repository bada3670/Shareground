## 맨 위로 가기 버튼에 debouncing을 적용하지 않은 이유

코드가 복잡해집니다.

처리를 하는 과정에서 자원이 많이 사용되는 것 같지 않아 보였습니다.

## 로그인/회원가입을 할 때 submit이 아닌 click으로 한 이유

동일한 input 이메일과 input 비밀번호로 로그인과 회원가입을 동시에 처리하고 싶었습니다.

그런데 submit으로는 로그인을 눌렀는지 회원가입을 눌렀는지 판단할 수가 없었습니다.

## 댓글을 Realtime에서 Firestore로 바꾼 이유

댓글 삭제 버튼을 누르는데 갑자기 Realtime이 반영이 되어서 잘못 누르게 될 수 있습니다.

Realtime에서 새로 고침을 하지 않으면 작성자가 다른 사람이 되는 현상이 발생했습니다.

## header의 category 및 auth의 웹 접근성

처음에는 그냥 hover만 하면 밑에 목록이 열리도록 하였습니다.

근데 그렇게 하려니 tab으로 해당 항목들이 열리지 않았습니다.

그래서 고민을 하던 중 CSS hover를 쓰면 안 되고 mouseenter와 mouseleave를 써야 함을 알았습니다.

그리고 그 과정에서 mouseover, mouseout와 mouseenter, mouseleave의 차이점을 알게 되었습니다.

## article을 수정하거나 삭제할 때 searchList를 변경하지 않는 이유

시간이 오래 걸립니다. 과정을 보면 다음과 같습니다. getDoc을 통해 배열을 가져와서 일일이 해당 아이디와 맞는지를 체크한 후 updateDoc을 해야 합니다. updateDoc은 await을 할 필요가 없습니다. 하지만 getDoc과 배열에서 체크하는 것은 반드시 그 자리에서 해야 합니다.

getDoc을 안 하고 Redux에서 가져오면 문제가 발생합니다. 왜냐하면 그동안 다른 유저가 글을 올렸을 수 있기 때문입니다. 다른 유저가 글을 올린 상태에서 해당 유저가 Redux에서 가져온 것을 반영해서 올리면 다른 유저가 올린 글이 삭제됩니다.

onSnapshot을 쓸 수도 있겠지만 그렇게 되면 부담이 커집니다.

배열이 아니라 key value로 하면 순환할 필요가 없지 않냐고 물으실 수 있습니다. 하지만 개수가 많아서 옛날 것을 삭제하려고 할 때 문제가 생깁니다. 왜냐하면 자료들 사이에 순서가 없기 때문입니다.

이미 오래된 글이어서 search에 없을 수 있습니다. 이러면 헛수고가 됩니다.

새로운 글들이 올라오면 자연스럽게 삭제됩니다.

## Card 컴포넌트에 작성자를 적지 않은 이유

이미 로딩이 SSR로 인해 체감상 많이 느린 상황(로딩 표시를 할 수 없으므로)에서 더 느려질 수 있습니다.

페이지네이션의 경우 바로 파이어베이스 측에서 하는 것이 아니라 기존의 것을 다 가져온 후 또 불러야 하는 상황입니다. 즉, 지금도 많이 느리다는 것입니다.

## 작성 목록과 관심 목록을 users collection이 아닌 articles collection에 저장한 이유

예를 들어 작성 목록을 생각하면 다음과 같습니다.

만약 users에 각 articleid를 넣는다면 articleid 하나 읽고, 글 가져오고, articleid 하나 읽고, 또 글 가져오는 번거로운 과정이 펼쳐집니다.

하지만 articles에 userid를 넣는다면 쿼리를 통해 금방 가져올 수 있습니다.

## Next.js의 API route를 사용한 이유

원래는 getDoc 등을 직접 컴포넌트에서 사용했습니다. 그러다가 API route를 사용했습니다.

처음에는 보안을 이유로 사용하려고 했습니다. Firebase URL이 브라우저 뜨지 않게 하기 위해서였습니다. 하지만 Firebase 측이 이런 것을 당연히 고려했을 것이라는 생각도 들었고, 해당 URL에 접속하면 아무것도 없어서 괜찮다고 생각했습니다. 또한 서버 사이드 렌더링 (SSR)에서는 URL이 absolute URL이어야 했습니다. 하지만 당시에는 이 사실을 몰랐습니다. 그래서 포기했습니다.

그런데 absolute URL이 무엇인지 알게 되고, 테스트를 하기 위해서 mocking을 하고 싶어서 API route를 사용하게 되었습니다.

쓰다 보니 다른 장점이 있었는데 그것은 컴포넌트 쪽의 코드가 단순해졌다는 것이었습니다.

예를 들어 글을 삭제할 때 파일이 있다면 이도 삭제해야 하는데, 이 경우 원래는 컴포넌트에 파일을 삭제하는 코드와 글을 삭제하는 코드를 둘 다 작성해야 했습니다. 하지만 API route를 쓰면 해당 정보만 보내면 그 처리는 API route에서 합니다.

처음부터 저렇게 코드를 작성한 것은 아니었습니다. 처음에는 Firebase의 메서드에 따라 작성했습니다. 그런데 하다 보니 저렇게 하는 것이 나아 보여서 저렇게 했습니다.

## husky를 사용하지 않은 이유

Cypress가 불안정합니다. 같은 코드임에도 불구하고 언제는 통과하고, 언제는 실패합니다. 실패하면 다시 돌려야 합니다. 시간이 짧게 걸리는 테스트면 괜찮겠지만 그렇지 않습니다. 또한 언제 끝난다는 보장도 없습니다.

수정하는 부분이 적을 경우 테스트를 다 돌릴 필요는 없다고 생각합니다. 특히 문서만 수정하는 경우 필요가 없습니다.

git commit을 할 때 CLI로 해야 합니다. VSCode로 하면 오류가 납니다.

## Auth 컴포넌트, Search 컴포넌트

해당 컴포넌트들의 경우 빈 엘리먼트(&lt;&gt;&lt;/&gt;)를 반환합니다.

이를 만든 이유는 다음과 같습니다. React-Redux에서는 dispatch를 하려면 Provider 컴포넌트 안에 있어야 하고, 해당 컴포넌트들의 기능상 모든 페이지에 적용되어야 합니다. Create React App이나 Vite의 경우 감싸는 Provider와 다른 컴포넌트들 사이에 중간 컴포넌트를 만들면 되지만 Next.js로는 불가능합니다. React-Redux를 쓰지 않을까도 생각해 보았지만 이 방법이 떠올라서 사용하였습니다.
